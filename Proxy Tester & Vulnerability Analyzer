import os
import tkinter as tk
from tkinter import scrolledtext, filedialog, messagebox, ttk
import requests
from bs4 import BeautifulSoup
from selenium import webdriver
import logging
import matplotlib.pyplot as plt
import random
import time


# Configuración de logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')


class ProxyTester:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Proxy Tester & Vulnerability Analyzer")
        self.root.geometry("800x600")
        self.root.configure(bg="#f4f4f4")

        # Cargar User-Agents
        self.user_agents = self.cargar_user_agents()
        self.selected_user_agent = tk.StringVar(value=self.user_agents[0])  # Valor por defecto

        # Crear un menú desplegable para seleccionar el User-Agent
        tk.Label(self.root, text="Seleccionar User-Agent:").pack(pady=10)
        self.user_agent_menu = ttk.Combobox(self.root, textvariable=self.selected_user_agent, values=self.user_agents)
        self.user_agent_menu.pack(pady=10)

        # Botón "Vamp"
        tk.Button(self.root, text="Vamp", command=self.vamp, bg="#d9534f", fg="white", font=("Arial", 12)).pack(pady=10)

        # Crear pestañas
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill='both', expand=True)

        # Pestaña de Proxies
        self.proxy_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.proxy_tab, text="Proxies")

        # Pestaña de Resultados y Estadísticas
        self.stats_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.stats_tab, text="Estadísticas")

        # Inicializar listas
        self.proxies = []
        self.resultados = []
        self.vulnerabilidades = []
        self.vulnerabilidades_detectadas = []

        # Configuración de las pestañas
        self.config_proxy_tab()
        self.config_stats_tab()

        # Crear carpeta para guardar resultados
        self.create_results_directory()
        self.result_file = os.path.join(self.results_directory, 'resultados.txt')

        # Abrir archivo para escribir resultados
        self.initialize_result_file()

    def create_results_directory(self):
        """Crea un directorio para guardar los resultados."""
        self.results_directory = os.path.join(os.getcwd(), 'ProxyTesterResults')
        os.makedirs(self.results_directory, exist_ok=True)

    def initialize_result_file(self):
        """Inicializa el archivo de resultados en blanco."""
        with open(self.result_file, 'w') as f:
            f.write("----- Resultados del Proxy Tester -----\n\n")

    def cargar_user_agents(self):
        """Carga una lista de user agents desde un archivo o define una lista común."""
        try:
            with open('user_agents.txt', 'r') as f:
                return [linea.strip() for linea in f.readlines()]
        except FileNotFoundError:
            return [
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15",
                "Mozilla/5.0 (Linux; Android 9; SM-G965F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Mobile Safari/537.36",
            ]

    def vamp(self):
        """Acción a realizar al presionar el botón 'Vamp'."""
        user_agent = self.selected_user_agent.get()
        self.log_and_display(f"User-Agent Seleccionado: {user_agent}")

    def config_proxy_tab(self):
        """Configura la pestaña de proxies."""
        self.frame = tk.Frame(self.proxy_tab, bg="#f4f4f4")
        self.frame.pack(fill="both", expand=True)

        tk.Label(self.frame, text="Proxy:", bg="#f4f4f4").pack(pady=5)
        self.proxy_entry = tk.Entry(self.frame, width=80)
        self.proxy_entry.pack(pady=5)

        tk.Button(self.frame, text="Probar Proxy", command=self.probar_proxy, bg="#5cb85c", fg="white").pack(pady=5)
        tk.Button(self.frame, text="Cargar Proxies desde Archivo", command=self.cargar_proxies, bg="#5bc0de", fg="white").pack(pady=5)

        tk.Label(self.frame, text="URL a Probar:", bg="#f4f4f4").pack(pady=5)
        self.url_entry = tk.Entry(self.frame, width=80)
        self.url_entry.pack(pady=5)

        tk.Button(self.frame, text="Probar URL", command=self.probar_url, bg="#5cb85c", fg="white").pack(pady=5)
        tk.Button(self.frame, text="Cargar URLs desde Archivo", command=self.cargar_urls, bg="#5bc0de", fg="white").pack(pady=5)

        tk.Label(self.frame, text="Seleccionar Método de Scraping:", bg="#f4f4f4").pack(pady=5)
        self.selenium_var = tk.IntVar()
        self.bs_var = tk.IntVar()
        self.create_checkbutton("Usar Selenium", self.selenium_var, "Usa Selenium para interactuar con páginas dinámicas.")
        self.create_checkbutton("Usar Beautiful Soup", self.bs_var, "Usa Beautiful Soup para analizar el HTML.")

        self.respuesta_text = scrolledtext.ScrolledText(self.frame, width=80, height=20, font=("Arial", 10), bg="#ffffff", fg="#333333")
        self.respuesta_text.pack(pady=5)

        self.tooltip_label = tk.Label(self.frame, bg='yellow', bd=1)
        self.tooltip_label.place_forget()

    def create_checkbutton(self, text, variable, tooltip):
        """Crea un Checkbutton con tooltip."""
        checkbutton = tk.Checkbutton(self.frame, text=text, variable=variable, bg="#f4f4f4")
        checkbutton.bind("<Enter>", lambda e: self.show_tooltip(e, tooltip))
        checkbutton.bind("<Leave>", lambda e: self.hide_tooltip())
        checkbutton.pack(pady=5)

    def show_tooltip(self, event, text):
        """Mostrar tooltip en la posición del mouse."""
        x = event.x_root + 10
        y = event.y_root + 10
        self.tooltip_label.place(x=x, y=y)
        self.tooltip_label.config(text=text)
        self.tooltip_label.update_idletasks()

    def hide_tooltip(self):
        """Ocultar tooltip."""
        self.tooltip_label.place_forget()

    def config_stats_tab(self):
        """Configura la pestaña de estadísticas."""
        self.stats_frame = tk.Frame(self.stats_tab)
        self.stats_frame.pack(fill="both", expand=True)
        tk.Button(self.stats_frame, text="Mostrar Estadísticas", command=self.mostrar_estadisticas, bg="#5cb85c", fg="white").pack(pady=10)

    def cargar_proxies(self):
        """Carga proxies desde un archivo."""
        archivo = filedialog.askopenfilename(title="Seleccionar archivo de proxies", filetypes=[("Archivos TXT", "*.txt")])
        if archivo:
            with open(archivo, "r") as f:
                proxies_cargados = [linea.strip() for linea in f.readlines()]
                self.proxies.extend(proxy for proxy in proxies_cargados if proxy not in self.proxies)
                logging.info(f"Cargados {len(proxies_cargados)} proxies desde archivo.")
                self.log_and_display(f"Cargados {len(proxies_cargados)} proxies desde archivo.")

    def cargar_urls(self):
        """Carga URLs desde un archivo."""
        archivo = filedialog.askopenfilename(title="Seleccionar archivo de URLs", filetypes=[("Archivos TXT", "*.txt")])
        if archivo:
            with open(archivo, "r") as f:
                urls_cargadas = [linea.strip() for linea in f.readlines()]
                self.log_and_display(f"Cargadas {len(urls_cargadas)} URLs desde archivo.")
                self.url_entry.delete(0, tk.END)
                self.url_entry.insert(tk.END, "\n".join(urls_cargadas))  # Ingresar cada URL

    def get_random_user_agent(self):
        """Devuelve un User-Agent aleatorio de la lista."""
        return random.choice(self.user_agents)

    def log_and_display(self, message):
        """Log y muestra mensajes en la interfaz y en el archivo."""
        timestamped_message = f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {message}\n"
        
        # Agregar al texto de respuesta
        self.respuesta_text.insert(tk.END, timestamped_message)
        self.respuesta_text.yview(tk.END)  # Desplazar hacia abajo

        # También escribir en el archivo de resultados
        with open(self.result_file, 'a') as f:
            f.write(timestamped_message)

    def probar_proxy(self):
        """Prueba un proxy específico."""
        proxy_actual = self.proxy_entry.get()
        if not proxy_actual:
            messagebox.showerror("Error", "Por favor ingrese un proxy.")
            return

        url = "https://hackerone.com"
        headers = {'User-Agent': self.get_random_user_agent()}

        try:
            session = requests.Session()
            respuesta = session.get(url, proxies={"http": proxy_actual, "https": proxy_actual}, headers=headers, timeout=5)

            resultado = f"Proxy {proxy_actual} funcionando correctamente.\n"
            resultado += f"Estado: {respuesta.status_code}\n"
            if respuesta.status_code == 200:
                resultado += "El proxy está operando adecuadamente.\n"
            else:
                resultado += "El proxy tiene problemas.\n"

            logging.info(f"Proxy {proxy_actual} funcionando correctamente.")
            self.resultados.append((proxy_actual, "Funciona"))
            self.log_and_display(resultado)

        except requests.exceptions.RequestException as e:
            logging.error(f"Proxy {proxy_actual} no funciona: {e}")
            self.log_and_display(f"Proxy {proxy_actual} no funciona: {e}")
            self.resultados.append((proxy_actual, "No Funciona"))

    def probar_url(self):
        """Prueba una URL específica."""
        url_a_probar = self.url_entry.get()
        
        if not url_a_probar:
            messagebox.showerror("Error", "Por favor ingrese una URL.")
            return

        start_time = time.time()  # Comenzar a medir el tiempo
        headers = {'User-Agent': self.get_random_user_agent()}  # User-Agent aleatorio

        try:
            respuesta = requests.get(url_a_probar, headers=headers)
            elapsed_time = time.time() - start_time  # Calcular el tiempo de respuesta

            resultado = f"--- Resultados de la Prueba de URL ---\n"
            resultado += f"URL: {url_a_probar}\n"
            resultado += f"Código de Estado: {respuesta.status_code}\n"
            resultado += f"Tiempo de Respuesta: {elapsed_time:.4f} segundos\n"
            resultado += f"--- Respuesta (Primeros 500 caracteres): ---\n{respuesta.text[:500]}...\n"

            if respuesta.status_code == 200:
                resultado += "Estado: Operativa\n"
            else:
                resultado += "Estado: No Operativa\n"

            # Log de la respuesta
            logging.info(f"Tiempo de respuesta para {url_a_probar}: {elapsed_time:.4f} segundos con status {respuesta.status_code}")
            self.log_and_display(resultado)

            # Analizar vulnerabilidades 
            self.analizar_vulnerabilidades(respuesta.text, url_a_probar)

            # Buscar información adicional en la página
            self.buscar_info_importante(url_a_probar, headers)

            if self.selenium_var.get() == 1:
                logging.info("Usando Selenium para scraping adicional.")
                page_source = self.automatizar_con_selenium(url_a_probar)
                if page_source:
                    self.analyze_selenium_data(page_source)

            if self.bs_var.get() == 1:
                logging.info("Usando Beautiful Soup para análisis adicional.")
                soup_data = BeautifulSoup(respuesta.text, 'html.parser')
                soup_resultado = soup_data.prettify()
                self.log_and_display("Datos Analizados (Beautiful Soup):\n" + soup_resultado[:500])

        except requests.exceptions.RequestException as e:
            logging.error(f"URL {url_a_probar} no funciona: {e}")
            self.log_and_display(f"URL {url_a_probar} no funciona: {e}")

    def analizar_vulnerabilidades(self, response_text, url):
        """Analiza vulnerabilidades en el texto de respuesta."""
        keywords = ["error", "vulnerability", "exploit", "attack", "unauthorized", "csrf", "xss", "sql", "access", "denial"]
        detected = [keyword for keyword in keywords if keyword in response_text.lower()]

        if detected:
            self.vulnerabilidades_detectadas.append((url, detected))
            self.log_and_display(f"Vulnerabilidades detectadas en {url}: {', '.join(detected)}")
            logging.info(f"Vulnerabilidades detectadas en {url}: {', '.join(detected)}")
        else:
            self.log_and_display(f"No se detectaron vulnerabilidades en {url}.")

    def buscar_info_importante(self, url_a_probar, headers):
        """Busca archivos importantes en la página, como PDF, JS, y otros."""
        try:
            respuesta = requests.get(url_a_probar, headers=headers)
            soup = BeautifulSoup(respuesta.text, 'html.parser')

            # Buscar archivos PDF y JS
            pdf_links = [a['href'] for a in soup.find_all('a', href=True) if a['href'].endswith('.pdf')]
            js_links = [script['src'] for script in soup.find_all('script', src=True)]
            api_endpoints = [link['href'] for link in soup.find_all('a', href=True) if "api" in link['href'].lower()]

            # Guardar la información en un archivo
            self.guardar_info_importante(url_a_probar, pdf_links, js_links, api_endpoints)
            self.download_robots_txt(url_a_probar)

        except Exception as e:
            logging.error(f"No se pudo buscar información importante en {url_a_probar}: {e}")

    def analyze_selenium_data(self, page_source):
        """Analiza los datos obtenidos por Selenium."""
        soup = BeautifulSoup(page_source, 'html.parser')
        links = [a['href'] for a in soup.find_all('a', href=True)]
        logging.info(f"Links obtenidos mediante Selenium: {links}")

        # Asegúrate de que hay algo para mostrar
        if links:
            self.log_and_display("Links Encontrados (Selenium):\n" + "\n".join(links[:5]))  # Muestra solo los primeros 5

    def guardar_info_importante(self, url, pdf_links, js_links, api_endpoints):
        """Guarda la información importante en un archivo de texto."""
        nombre_archivo = os.path.join(self.results_directory, 'info_importante.txt')

        with open(nombre_archivo, 'w') as f:
            f.write(f"Información recopilada sobre {url}:\n")
            f.write("\nPDFs encontrados:\n")
            f.write("\n".join(pdf_links) if pdf_links else "No se encontraron PDFs.\n")

            f.write("\nArchivos JS encontrados:\n")
            f.write("\n".join(js_links) if js_links else "No se encontraron archivos JS.\n")

            f.write("\nEndpoints de API encontrados:\n")
            f.write("\n".join(api_endpoints) if api_endpoints else "No se encontraron endpoints de API.\n")

        logging.info(f"Información guardada en {nombre_archivo}")

    def download_robots_txt(self, url):
        """Descarga el archivo robots.txt del dominio."""
        try:
            domain = '/'.join(url.split('/')[:3])  # Extraer el dominio
            robots_url = f"{domain}/robots.txt"
            response = requests.get(robots_url)
            if response.status_code == 200:
                robots_file = os.path.join(self.results_directory, 'robots.txt')
                with open(robots_file, 'w') as f:
                    f.write(response.text)
                logging.info(f"robots.txt guardado en {robots_file}")
            else:
                logging.warning(f"No se encontró robots.txt en {robots_url}")
        except Exception as e:
            logging.error(f"Error al descargar robots.txt: {e}")

    def mostrar_estadisticas(self):
        """Muestra las estadísticas sobre los proxies probados y las URLs."""
        if not self.resultados:
            messagebox.showwarning("Advertencia", "No hay resultados para mostrar.")
            return

        funcionantes = sum(1 for _, estado in self.resultados if estado == "Funciona")
        no_funcionantes = sum(1 for _, estado in self.resultados if estado == "No Funciona")

        # Crear gráficos de estadísticas
        self.graficar_proxies(funcionantes, no_funcionantes)
        self.graficar_vulnerabilidades()

    def graficar_proxies(self, funcionantes, no_funcionantes):
        """Genera un gráfico de pastel de los resultados de los proxies."""
        labels = ['Funciona', 'No Funciona']
        sizes = [funcionantes, no_funcionantes]

        # Gráfico de pastel de proxies
        fig, ax = plt.subplots()
        ax.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90, colors=['#5cb85c', '#d9534f'])
        ax.axis('equal')
        plt.title('Distribución de Resultados de Proxies')
        plt.show()

        # Crear informe en texto
        self.log_and_display(f"Total Proxies: {len(self.proxies)}")
        self.log_and_display(f"Funciona: {funcionantes} ({(funcionantes/len(self.proxies))*100:.2f}%)")
        self.log_and_display(f"No Funciona: {no_funcionantes} ({(no_funcionantes/len(self.proxies))*100:.2f}%)")

    def graficar_vulnerabilidades(self):
        """Genera un gráfico para las vulnerabilidades detectadas."""
        if not self.vulnerabilidades_detectadas:
            self.log_and_display("No se detectaron vulnerabilidades en las URLs probadas.")
            return

        # Contar las vulnerabilidades
        vulnerabilidad_counts = {}
        for url, vulnerabilidades in self.vulnerabilidades_detectadas:
            for vulnerabilidad in vulnerabilidades:
                if vulnerabilidad in vulnerabilidad_counts:
                    vulnerabilidad_counts[vulnerabilidad] += 1
                else:
                    vulnerabilidad_counts[vulnerabilidad] = 1

        # Crear gráfico de barras
        plt.bar(vulnerabilidad_counts.keys(), vulnerabilidad_counts.values(), color='#5bc0de')
        plt.title('Frecuencia de Vulnerabilidades Detectadas')
        plt.xlabel('Vulnerabilidades')
        plt.ylabel('Cantidad Detectada')
        plt.xticks(rotation='vertical')
        plt.tight_layout()
        plt.show()

        # Informe sobre vulnerabilidades
        self.log_and_display("Vulnerabilidades Detectadas:")
        for vulnerabilidad, count in vulnerabilidad_counts.items():
            self.log_and_display(f"{vulnerabilidad}: {count} veces")

    def automatizar_con_selenium(self, url):
        """Automatiza la navegación con Selenium."""
        opciones = webdriver.ChromeOptions()
        opciones.add_argument("--headless")

        try:
            navegador = webdriver.Chrome(options=opciones)
            navegador.get(url)
            time.sleep(2)  # Esperar a que la página cargue completamente
            
            page_source = navegador.page_source
            logging.info(f"Selenium automatizado correctamente en {url}")
            return page_source
            
        except Exception as e:
            logging.error(f"Error en Selenium: {e}")
            messagebox.showerror("Error", f"No se pudo automatizar con Selenium: {e}")

    def run(self):
        """Iniciar la aplicación."""
        try:
            logging.info("Iniciando Proxy Tester...")
            self.root.mainloop()
        except Exception as e:
            logging.error(f"Ocurrió un error al ejecutar la aplicación: {e}")
            messagebox.showerror("Error Crítico", f"Ocurrió un error al ejecutar la aplicación: {e}")


if __name__ == "__main__":
    tester = ProxyTester()
    tester.run()
